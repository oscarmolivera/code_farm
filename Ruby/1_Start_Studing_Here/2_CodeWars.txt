1) 2) 3) 4) 5) 6) 7) 8) 9) 

1) Up Array
Given an array of integers of any length, return an array that has 1 added to the value
represented by the array.
The array can't be empty, only non-negative, single digit integers are allowed.

Return nil (or your language's equivalent) for invalid inputs.

Sample Test Cases {
  p up_array([2, 3, 9]) # => [2, 4, 0]
  p up_array([4, 3, 2, 5]) # => [4, 3, 2, 6]
  p up_array([1, -9]) # => nil
  p up_array([1, 2, 34]) # => nil
  p up_array([0, 1]) # =>  [0, 2]
  p up_array([]) # => nil
}
[
  * convertir todos los elementos del arreglo en un numero sting (.JOIN)
  * sumarle uno mas con el metodo .SUCC
  * volverlo a convertir en un arreglo con .CHARS
  * iterar con .MAP para convertir cada numero en un entero otra vez
  * comparar el tamaÃ±o de l arreglo contra el string creado con .JOIN si son diferentes retornar nil
]

---------------------
2)Vowel count
Return the number (count) of vowels in the given string. We will consider a, e, i, o, and
u as vowels for this Kata.
The input string will only consist of lower case letters and/or spaces.

Sample Test Cases {
  p vowel_count('usando') # => 3
  p vowel_count('ele ent o') # => 4
  p vowel_count(' rmpdl zdr') # => 0
}
[
  * usando el metodo .SCAN crear un arreglo a partir de el regexp /[aeiou]/
  * .COUNT al arreglo
]
---------------------        
3)Series Sum.
Your task is to write a function which returns the sum of following series upto nth term(parameter).
Series: 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 +...

Rules:
    You need to round the answer to 2 decimal places and return it as String.
    If the given value is 0 then it should return 0.00
    You will only be given Natural Numbers as arguments.

Sample Test Cases {
  p series_sum(0)  # => "0.00"
  p series_sum(1)  # => "1.00"
  p series_sum(2)  # => "1.25"
  p series_sum(5)  # => "1.57"
  p series_sum(10) # => "1.81"
}
[
  * Hay varias formas de enfrentar este problema
  * Primero hay que retornar '0.00' si el numero es menor a 1
  * luego se crea un rango de 1 hasta el numero recibido en el argumento
  * por cada interaccion usando .MAP se toma el numero y se divide por la formula 1.0/(n + (2 *(n-1)))
  * se reduce todo el arreglo creado sumando todos sus elementos con .reduce
  * por ultimo se retorna el string de esa reduccion usando sprintf('%.2f', numero)
]
---------------------
4) 
---------------------
5)
---------------------        
6)
---------------------
7) 
---------------------
8)
---------------------        
9)
---------------------
10) 
---------------------